[{"title":"","date":"2020-10-21T01:55:34.436Z","path":"2020/10/21/index/","text":"","tags":[]},{"title":"【算法与数据结构 02】树的引入","date":"2020-10-08T08:07:02.000Z","path":"2020/10/08/【算法与数据结构 02】二叉树的引入/","text":"【算法与数据结构 02】二叉树的引入 相信大家对于树都不会太陌生，今天就来简单聊聊关于数据结构中的树的那些东西吧~ [toc] 一、树的简单介绍1.1 什么是树？ 先来看看百度百科上对树的解释 树状图是一种数据结构，它是由n(n &gt;= 1) 个有限结点组成一个具有层次关系的集合 把它叫做 “树” 是因为它看起来像一颗倒挂的树，也就是说它是根朝上，而叶朝下 它大多长这样： 再来看看一些结点的称呼或是概念性的东西 A 结点是 B 和 C 结点的上级，也就是说 A 结点是 B 和 C 结点的父节点，B 和 C 结点是 A 结点的子结点 B 和 C 结点同时是 A 结点的子结点，称为兄弟结点 A 结点没有父节点，称为根节点 D 、E 和 F 结点没有子结点，称为叶子节点 树深即为树中结点的最大层次数（也称高度，深度），如图深度即为 3 可以看出，树由根结点和若干颗子树构成，换句话说，剔除一颗树的根节点后，它的子结构也满足树的特性： 每个结点有零个或多个结点 每个非根结点有且仅有一个父节点 树里面没有环路 提到树就不得不说起二叉树了 1.2 什么是二叉树二叉树：每个结点最多含有两个结点的树，两个结点分别为左子结点和右子结点 来看看一个二叉树的简单实现 123456789101112public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 二叉树当中也有几种特殊的类型： 满二叉树：所有结点都有两个子结点（当然除开最后一层的叶子结点） 完全二叉树：除最后一层结点个数都达到最大，并且最后一层的叶子结点都往左排列 （从定义可以发现，一个满二叉树一定是完全二叉树） 之所以会称为完全二叉树，是从它存储空间利用率来看的 比如上面的完全二叉树： 0 1 2 3 4 5 6 7 8 A B C D E F G H 如果这里是一颗非完全二叉树，则会浪费比较多的存储空间： 0 1 2 3 4 5 6 7 A B C D E F 8 9 10 11 12 13 14 15 G H I 二叉搜索树：满足下列约束条件： 若左子树不为空，则左子树上所有结点的值均小于它的根节点的值 若右子树不为空，则右子树上所有结点的值均大于它的根节点的值 左、右子树也必须是二叉搜索树 二叉查找树中，会尽可能避免两个结点数值相等的情况 二叉查找树也有几种优化，例如 AVL 树、红黑树、哈夫曼树 … 之后再做介绍 二、二叉树的遍历方式二叉树的遍历是指从根结点触发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问且仅被访问一次 二叉树的遍历方式大体上有四种经典方式：前序遍历、中序遍历、后序遍历、层序遍历 其中前序、中序和后序遍历本质上可以认为是深度优先遍历（DFS），而二叉树的层序遍历本质上可以认为是广度优先遍历（BFS），这里不作详细介绍，想了解的朋友可以期待下一篇文章哦~ DFS 简单来说就是对每一个可能的分支路径深入到最底的遍历方式；而 BFS 简单来说就是一层一层由内而外的遍历方式 前序遍历：对于树中的任意结点，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树 中序遍历：对于树中的任意结点，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树 后序遍历：对于树中的任意结点，先后序遍历它的左子树，然后 后序遍历它的右子树，最后打印这个结点 （也就是说，这里的序指的是父节点的遍历顺序） 实现前序、中序和后序遍历普遍用的还是递归，个人觉得递归相比非递归的方法更妙一些~，下面贴出代码片段方便大家理解 其实这三种遍历方式有很大的相同之处，正如它们的定义一般 2.1 前序遍历12345678public static void preOrderTraversal(TreeNode head) &#123; if (head == null) &#123; return; &#125; System.out.print(head.val + &quot; &quot;); preOrderTraversal(head.left); preOrderTraversal(head.right);&#125; 2.2 中序遍历12345678public static void inOrderTraversal(TreeNode head) &#123; if (head == null) &#123; return; &#125; inOrderTraversal(head.left); System.out.print(head.val + &quot; &quot;); inOrderTraversal(head.right);&#125; 这里额外提一下二叉查找树的中序遍历： 对二叉查找树进行中序遍历，就可以输出一个按数值从小到大的有序数据队列（这里就直接拿上面的图吧，偷懒~） 比如这里就会打印出：9、13、15、16、18、21、23、25 2.3 后序遍历12345678public static void postOrderTraversal(TreeNode head) &#123; if (head == null) &#123; return; &#125; postOrderTraversal(head.left); postOrderTraversal(head.right); System.out.print(head.val + &quot; &quot;);&#125; 2.4 层序遍历层序遍历就像上面所提到的那样，即逐层的、从左到右访问所有结点 层序遍历的实现可以使用队列的特性，把每个还没有访问到的结点依次放入队列，然后再弹出队列的头部元素当作是当前的结点： 12345678910public static void levelOrder(TreeNode head)&#123; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(head); while (!queue.isEmpty())&#123; TreeNode cur = queue.poll(); System.out.print(cur.val + &quot; &quot;); if(cur.left != null) queue.add(cur.left); if(cur.right != null) queue.add(cur.right); &#125;&#125; 使用队列保存每层的所有结点，每次把队列里原先的所有结点进行出队列操作，再把每个元素的非空左右子节点入队，即可得到每层的遍历 时隔五个月左右自己又有了写博客的想法，希望自己能一直坚持下去，另外，朋友们的点赞和关注是对我最大的支持 :D","tags":[{"name":"-数据结构 -树","slug":"数据结构-树","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"}]},{"title":"【算法与数据结构 01】动态规划之引入","date":"2020-04-09T08:31:51.000Z","path":"2020/04/09/【算法与数据结构 01】动态规划之引入/","text":"【算法与数据结构 01】动态规划之引入 前言 前几天在力扣刷题时遇到了动态规划的问题，看了题解之后有些兴趣便自己下去多了解了一下，在此分享给大家（另外给的例题都是自己做过的，然后思考了下顺便分享下，希望大家喜欢~） 本篇博客将分为两个部分： 对动态规划进行阐述 配合一些动态规划的题目进一步了解 那么接下来就让我们开始吧~ 引入定义动态规划（Dynamic programming，简称 DP）中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。换言之就是原问题可以拆解成若干个子问题，而这些子问题又可拆解……最后可以由初始问题的解来推出原问题的解。 而这之中拆解的过程又是耐人寻味的且有趣的。 使用要素（划重点！） 最优子结构：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。换言之，总问题包含很多个子问题，而这些子问题的解也是最优的。 子问题的重叠性：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。而动态规划利用了这个性质，对每一个子问题都计算一次，将结果保存在一个表格中（例如数组），之后要用的时候取出来就行，就不必再重新计算，提高了效率。 也许到这你还是对动态规划不是很理解，那么就来谈谈这当中的经典问题：爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 初看觉得可以用排列组合来解，但那样的话n 越大越难解，效率也会很低 这时就要提到动态规划了： n阶台阶可以分为n-1阶台阶走一阶台阶和n-2阶台阶走两步，所以，n阶台阶的走法就是n-1阶台阶走法加上n-2阶台阶走法。这时可得状态转移方程：F(n) = F(n-1) + F(n-2) (n &gt;= 3)（这里如果是n-2阶台阶走1 1 两次的话，又会回到n-1阶台阶上） 将原问题进行拆解，也就是随着n 的减少，到最后剩下1阶台阶和2阶台阶，而1阶台阶只能是走1步，2阶台阶可以是1 1 走两次和走2步到，所以可得F(1) = 1, F(2) = 2，这就是问题的边界 可以看出，从最开始的问题解可以逐渐推出最终问题的解，妙啊~ 所以动态规划问题的精髓就在于状态转移方程 相关题目LeetCode 面试题 17.16. 按摩师 初看完题目，可以确定的是一个状态所能达到的最长总时间与之前两个状态和本状态的分钟数有关 观察题目，因为是不能接收相邻的预约，而且预约的总时间要最长，所以第i次、第i-1次和第i-2次预约就有了关系： 如果接收第i次预约，那么第i-1次预约就休息，此时i-2次预约所能达到的最长总时间 加上第i次预约的时间nums[i]就得大于第i-1次预约所能达到的最长总时间 如果不接受第i次预约，那么第i-1次预约的状态就不确定（由i-1次预约前的总时间数确定，但i-1次预约所能达到的最长总时间数 是可以确定的），此时i-2次预约所能达到的最长总时间 加上第i次预约的时间nums[i]就得小于第i-1次预约所能达到的最长总时间 定义dp[i]为[0,i]区间内预约所能达到的最长总时间数 所以这时的状态转移方程就为dp[i] = max(dp[i-2] + nums[i], dp[i-1]) 随着i 的减少，最后来到了边界上：i = 0和i = 1（i = 2即可由这两个值所得出） i = 0时，因为之前没有总时间数所限制，此时dp[0] = nums[0] i = 1时，因为和i = 0是相邻的，此时dp[1] = max(nums[0], nums[1]) 到这里本题差不多就解完了，再贴出部分代码以帮助大家理解： 123456789int len = nums.length;int[] dp = new int[len];dp[0] = nums[0];dp[1] = Math.max(nums[0], nums[1]);for(int i = 2;i &lt; len;i++)&#123; dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);&#125; LeetCode 32. 最长有效括号 这里先解释一下有效括号字符串：仅由 &quot;(&quot; 和 &quot;)&quot; 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。换句话说，一个有效括号是由&quot;)&quot;结尾的。 要注意的是题目找的是最长的有效括号的子串，也就是说满足定义的子串如果不连续就只需要最长的，举个例子：&quot;()))()())&quot;，这里应该输出4。 根据题目给的例子可以看到，遇到&quot;......()&quot;这样的，最长有效括号长度就加2，另外可能还有&quot;......(())&quot;这样的，也是满足有效括号的定义的，这里就直接加4。 可以发现，当前元素为&quot;(&quot;时，有效括号长度并不会发生变化，因此可以从&quot;)&quot;寻找出dp方程的一个关系，这里可以定义dp[i]的值为以第i个元素结尾时，最长有效括号子字符串的长度，这样的话就会出现两种情况（这里为了简化，dp[i]为&quot;(&quot;时，其值就直接为 0）： 当元素&quot;)&quot;前一个元素为&quot;(&quot;时，也就是形如&quot;......()&quot;这样的子字符串，可以推出： 1dp[i] = dp[i - 2] + 2 当元素&quot;)&quot;前一个元素为&quot;)&quot;时，也就是形如&quot;......))&quot;这样的子字符串。这里就要稍微复杂些，因为还要考虑前一个&quot;)&quot;的情况。假设这样的子字符串是一个更长的有效子字符串的一部分，那么前面就有与之对应的&quot;(&quot;，那么再前面的呢，又怎么去找？ 假设成立的情况下，这时的子字符串就类似于这样&quot;...((...))&quot;，而中间一定会出现&quot;...()...&quot;这样的子串，这时就回到了第一种情况，于是就可以通过&quot;...()...&quot;中的&quot;)&quot;来推出下一个元素&quot;)&quot;的dp[i]的值。仔细想想，由于是第一种情况推出来的，那么&quot;......))&quot;这里前一个元素&quot;)&quot;的dp[i]的值就意味着以它结尾的子串&quot;...(...)&quot;的有效子字符串的长度。 想到这里，就可以去找出前面的有效子串的长度了： 1dp[i] = dp[i - dp[i-1] - 2] + dp[i-1] + 2 这里举个例子方便去理解： i 0 1 2 3 4 5 6 s[i] ( ( ) ( ( ) ) dp[i] 0 0 2 0 0 2 6 如果你想问假设出现很多个&quot;......))))))&quot;这样的情况的话，其实这都是第二种情况的递推，或者说第二种情况是该情况的子问题 到这里本题差不多就解完了，但要注意越界的问题，这里贴出部分代码以帮助大家理解： 1234567891011121314151617class Solution &#123; public int longestValidParentheses(String s) &#123; int len = s.length(), max = 0; int[] dp = new int[len]; for (int i = 1; i &lt; len; i++) &#123; if (s.charAt(i) == &#x27;)&#x27;)&#123; if (s.charAt(i-1) == &#x27;(&#x27;)&#123; dp[i] = (i &gt;= 2 ? dp[i-2] : 0) + 2; &#125; else if (i - dp[i-1] &gt; 0 &amp;&amp; s.charAt(i - dp[i-1] - 1) == &#x27;(&#x27;)&#123; dp[i] = ((i - dp[i-1]) &gt;= 2 ? dp[i - dp[i-1] - 2] : 0) + dp[i-1] + 2; &#125; max = Math.max(max, dp[i]); &#125; &#125; return max; &#125;&#125; LeetCode72. 编辑距离 初看完这道题，我自己的想法是直接嵌套循环去找不同，但那些显然不合适（也不说写得出来不，时间估计都超了） 这道题其实在于怎么去寻找子问题，从而将原问题进行拆解：这一状态可以看成是由上一状态经过插入、删除、替换操作转换过来的 另外可以发现使用一维的dp[]不好去定义它，所以这里可以用二维的dp[][]，那么这里dp[i][j]就代表word1中从头到i位置的部分 转换成 word2中从头到j位置的部分 所需要的最少操作数 将原问题进行拆解，拆解成子问题，子问题再进行拆解…那么初始情况又怎么去找呢，也就是边界怎么去确定呢：考虑到word1或者word2可能为空字符的情况，这里放一张表方便大家去理解（这里借由实例1，给出部分数据，以下讨论也是建立在实例1的基础上） &#39;&#39; r o s &#39;&#39; 0 1 2 3 h 1 ◆1 ▼2 o 2 ●2 r 3 2 s 4 3 e 5 4 &#39;&#39;即为空字符，dp[i][j]的值即为最少操作数（比如说表中那个5即表示horse至少经过5次删除操作后可以得到空字符&#39;&#39;) 这里还需要确定的是插入、删除、替换 操作怎么通过代码去实现（还请理解不到的朋友们仔细看表格） 回到给的表格中，可以看到第一个位置为0，意思是两者都为空字符，不需要进行操作，因此操作数为0，如果这时word1和word2的第一个字符相等的话，那么也不需要进行操作，所以这里需要分情况讨论： 当word1[i] == word2[j]的时候，表示最新的一步不需要进行操作，也就是说此时word1[1 ~ i-1]转换成word2[1 ~ j-1]的最少操作数 与 word1[1 ~ i]转换成word2[1 ~ j]的最少操作数是一样的 所以可以得出：dp[i][j] = dp[i-1][j-1] 当word1[i] != word2[j]的时候，表示最新的一步需要进行操作： 替换操作：比如说word1第一个字符 与 word2第一个字符 可以直接替换所得（对应表格中打◆的1） 这里可以得出：dp[i][j] = dp[i-1][j-1] + 1 删除操作：前面有提到，比如说word1前两个字符ho先是经过一次替换得到ro，要再得到r，则需要一次删除操作（对应表格中打●的2） 这里可以得到：dp[i][j] = dp[i-1][j] + 1 插入操作：比如说word1前一个字符h要得到ro，先是h要进行替换得到r，再进行插入操作（对应表格中打▼的2） 这里可以得到：dp[i][j] = dp[i][j-1] + 1 因为要得到最少操作数，所以这里表示为 1dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1; 到这里本题也差不多解完了，这里再贴出部分代码帮助大家理解： 1234567891011121314151617181920212223242526class Solution &#123; public int minDistance(String word1, String word2) &#123; int len1 = word1.length(), len2 = word2.length(); int[][] dp = new int[len1+1][len2+1]; for (int i = 0; i &lt;= len1; i++) &#123; dp[i][0] = i; &#125; for (int j = 0; j &lt;= len2; j++) &#123; dp[0][j] = j; &#125; char[] words1 = word1.toCharArray(); char[] words2 = word2.toCharArray(); for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; if (words1[i-1] == words2[j-1])&#123; dp[i][j] = dp[i-1][j-1]; &#125; else &#123; dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1; &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125; 参考 所给例题的题解 程序员小灰—— 漫画：什么是动态规划？ 后话 这篇文章自己是二十多天前开始写的，加上自己还不太会写博客，以及老师布置的作业实在是太多了…趁着五一假期还是把它给码完了 QAQ 创作不易，如果大家喜欢的话可以点个赞 :D","tags":[{"name":"-算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java学习之synchronized锁","date":"2020-03-04T02:00:50.000Z","path":"2020/03/04/Java学习之synchronized锁/","text":"Java学习之synchronized锁 前言本文章主要对synchronized锁机制进行讲述 本人第一次写博客，如有不足，还请大家包含，谢谢~~ 那么接下来就开始吧~ 引入当多个线程同时进行时，线程的调度是由操作系统决定的，也就是说各个线程执行的先后顺序是无法确定的 如果多个线程同时读写共享变量，读取的数据就会不一致： 123456789101112131415161718192021222324252627282930313233public class Main &#123; public static void main(String[] args) throws Exception &#123; AddThread add = new AddThread(); DevThread dev = new DevThread(); add.start(); dev.start(); add.join(); dev.join(); System.out.println(&quot;count = &quot; + Counter.count); &#125;&#125;class Counter&#123; public static int count = 0;&#125;class AddThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Counter.count++; &#125; &#125;&#125;class DevThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Counter.count--; &#125; &#125;&#125; 当然，这里的count从逻辑上来讲应该是0 的 但多次运行之后可以发现，有时结果会是0，也会出现-259，-1228，422 … 之类很奇怪的数 要使结果正确，必须保证是原子操作 原子操作与可见性原子操作是指不能被中断的一个或一系列的操作 举个例子： 1i = i + 1; 这样一个简单的语句其实对应3 个操作： 读取变量i的值 进行加1 操作 将新的值赋值给变量i 例如上述程序执行时可能会像这样： 这样count的值会因为线程执行时被操作系统中断而使得最终结果发生变化 同时还需要保证可见性： 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到被修改的值 synchronized锁通过加锁和解锁的操作，可以保证某一线程执行时，其他线程处于等待状态： 使用synchronized关键字对一个对象进行加锁，即可保证代码块在任意时刻最多只有一个线程能执行： 123synchronized(lock) &#123; i = i + 1;&#125; 在使用synchronized的时候，在代码块结束的时候都会正确释放锁，不必担心是否会出现异常 当然，这里的lock 可以是客户端锁（随便用一个对象作为锁，不推荐 –&gt; 代码逻辑容易混乱，也不利于封装）： 12345public static final Object lock = new Object();...synchronized(lock) &#123; ...&#125; 也可以是内置锁（this即当前实例，每一个对象都有一个内置锁）： 123synchronized(this) &#123; ...&#125; 如果锁住的是this实例时，等同于用synchronized修饰这个方法（这个方法就是同步方法，表示整个方法都必须用this加锁）： 123public synchronized void test() &#123; // 锁住this ...&#125; // 解锁 那如果这个方法是静态方法呢？静态方法是没有this实例的 这时其实锁住的是该类的class实例（类锁），相当于： 1234567public class Student &#123; public static void test() &#123; synchronized(Student.class) &#123; ... &#125; &#125;&#125; 于是，通过使用synchronized，最开始遇到的问题就可以得到解决了： 1234567891011121314151617class AddThread extends Thread&#123; @Override public synchronized void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Counter.count++; &#125; &#125;&#125;class DevThread extends Thread&#123; @Override public synchronized void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Counter.count--; &#125; &#125;&#125; 用synchronized去修饰着两个方法，结果就会正确了~ 注意使用synchronized的时候，获取到的是哪个锁很重要，锁对象如果不对，代码逻辑就不对 另外还需要注意一些不需要synchronized的操作 JVM 规范定义了几种原子操作： 基本类型（long和double除外）赋值（多行赋值语句必须保证是同步操作） 引用类型赋值 这里long和double是64 位数据，但在x64 平台的JVM 是把long和double的赋值作为原子操作实现的，所以这个问题一般忽略 使用synchronized解决了多线程同步访问共享变量的问题 但因为synchronized代码块无法并发执行，加锁和解锁需要消耗一定的时间，它也带来了性能的下降 如果文章有什么不足，欢迎大家评论指出；如果本文对大家有什么帮助的话，也希望能点个赞，谢谢大家~","tags":[{"name":"-Java -锁","slug":"Java-锁","permalink":"http://yoursite.com/tags/Java-%E9%94%81/"}]}]